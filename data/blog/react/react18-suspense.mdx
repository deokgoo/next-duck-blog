---
title: "React suspense"
date: "2022-07-10"
tags: ['react', 'react18', 'suspense']
draft: true
summary: 'React18 대비하자 suspense'
---

# 들어가기전에
React18 Suspense에 관해 공부하다가 discussions에 있는 글을 읽고 정리하고 한 번에 기억할 수 있도록 요약하고자 합니다. <br/>
[New Suspense SSR Archietecure in React18](https://github.com/reactwg/react-18/discussions/37)

<br/><br/>

# SSR의 문제점
오늘날의 많은 서비스들이 SSR방식을 사용합니다. 

> fetch data (server) → render to HTML (server) → load code (client) → hydrate (client)

`SSR`은 위 와 같은 방식으로 진행되며 이전 단계가 끝나기전에 다음 단계로 나가지 못 하여 문제점들이 발생한다.
- HTML을 내보내기 전에 서버에서 데이터들을 모아놔야한다 (서버 내에서 API호출, 데이터 접근 등)
- 하이드레이션을 시작하기 전에 모든 컴포넌트를 대상으로한 JS가 클라이언트상에 불러와져야 한다.
- 일부 컴포넌트만 하이드레이션을 할 수 없다.

해결방법은 각각의 부분들에 대해 특정 단계를 수행할 수 있게하면 좋겠다라는 아이디어에서 `Suspense`가 활약을 합니다.

<br/><br/>

# Suspense란?
- React 16.6 버전에서는 코드를 불러오는 동안 “기다릴 수 있고”, 기다리는 동안 로딩 상태(스피너와 같은 것)를 선언적으로 지정할 수 있도록 `<Suspense>` 컴포넌트가 추가되었습니다.
- 데이터 로딩에 초점을 두지만, React18 부터 `<Suspense>`는 이미지, 스크립트, 그 밖의 비동기 작업을 기다리는 데에도 사용될 수 있습니다.

(https://ko.reactjs.org/docs/concurrent-mode-suspense.html)

## Suspense를 사용하기 위해서는
1. render stream 방식을 `renderToPipeableStream` 로 변경 <br/>
&nbsp;&nbsp;renderToString: Keeps working (with limited Suspense support) <br/>
&nbsp;&nbsp;renderToNodeStream: Deperecated (with full Suspense support, but without streaming) <br/>
&nbsp;&nbsp;renderToPipeableStream: New and recommended (with full Suspense support and streaming) <br/>

2. 아래와 같이 createRoot로 변경
```javascript
const rootElement = document.getElementById("root");
ReactDOM.createRoot(rootElement).render(<App />);
```

## Suspense의 장점
### HTML 스트리밍과 선택적 하이드레이션

<div className="flex flex-col items-center flex-wrap -mx-2 overflow-hidden xl:-mx-2">
  <div className="my-1 px-2 w-1/4 overflow-hidden xl:my-1 xl:px-2 xl:w-1/4">
    ![focus](https://media3.giphy.com/media/yoJC2D22ruCQKUM1bi/giphy.gif?cid=ecf05e47brp60ybkq5m31xoopnlb0w9p0g71adxefhfyc0j9&rid=giphy.gif&ct=g)
  </div>
</div>
